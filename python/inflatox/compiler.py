#  Copyright© 2024 Raúl Wolters(1)
#
#  This file is part of Inflatox.
#
#  Inflatox is free software: you can redistribute it and/or modify it under
#  the terms of the European Union Public License version 1.2 or later, as
#  published by the European Commission.
#
#  Inflatox is distributed in the hope that it will be useful, but WITHOUT ANY
#  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
#  A PARTICULAR PURPOSE. See the European Union Public License for more details.
#
#  You should have received a copy of the EUPL in an/all official language(s) of
#  the European Union along with Inflatox.  If not, see
#  <https://ec.europa.eu/info/european-union-public-licence_en/>.
#
#  (1) Resident of the Kingdom of the Netherlands; agreement between licensor and
#  licensee subject to Dutch law as per article 15 of the EUPL.

# System imports
import os
import subprocess
import sys
import tempfile
import textwrap
from datetime import datetime
from sys import version as sys_version

# Sympy imports
import sympy
from sympy.printing.c import C99CodePrinter

# Internal imports
from .symbolic import InflationModel
from .version import __abi_version__, __version__


class CInflatoxPrinter(C99CodePrinter):
    """C99CodePrinter with modified `_print_Symbol` method. Converting Sympy
    expressions with this printer will map all sympy symbols to either:
      - `x[i]` for symbols that must be interpreted as coordinates on the scalar
      manifold
      - `args[i]` for other symbols
    Which symbols should be interpreted as coordinates and which ones should not
    can be specified with the class constructor by passing it the appropriate
    value for the `coordinate_symbols` argument.
    """

    def __init__(
        self,
        coordinate_symbols: list[sympy.Symbol],
        coordinate_derivative_symbols: list[sympy.Symbol],
        settings=None,
    ):
        super().__init__(settings)
        coord_dict = {}
        for i, symbol in enumerate(coordinate_symbols):
            coord_dict[super()._print_Symbol(symbol)] = f"x[{i}]"
        dotcoord_dict = {}
        for i, symbol in enumerate(coordinate_derivative_symbols):
            dotcoord_dict[super()._print_Symbol(symbol)] = f"xdot[{i}]"
        self.coord_dict = coord_dict
        self.dotcoord_dict = dotcoord_dict
        self.param_dict = {}

    def print_preamble(self, model_name: str):
        """prints preamble in generated c code"""
        return f"""// This source file was automatically generated by Inflatox
// Model: {model_name}, timestamp: {datetime.now().strftime("%Y-%m-%d, %H:%M:%S")}
// Inflatox version: v{__version__}
// System info: {sys_version}

#include <math.h>
#include <stdint.h>
#ifndef M_PI
#define M_E 2.71828182846 
#define M_LOG2E 1.44269504089
#define M_LOG10E 0.4342944819
#define M_LN2 0.69314718056
#define M_LN10 2.30258509299
#define M_PI 3.14159265359
#define M_PI_2 1.57079632679
#define M_PI_4 0.78539816339
#define M_1_PI 0.31830988618
#define M_2_PI 0.63661977236
#define M_2_SQRTPI 1.1283791671
#define M_SQRT2 1.41421356237
#define M_SQRT_1_2 0.70710678118
#endif
"""

    def _print_Symbol(self, expr):
        """Modified _print_Symbol function that maps sympy symbols to argument indices"""
        if expr.is_number:
            return expr.evalf(self._settings["precision"])

        sym_name = self.get_symbol(expr)
        if sym_name is not None:
            return sym_name
        else:
            return self.register_parameter(expr)

    def register_parameter(self, symbol: sympy.Symbol) -> str:
        """Adds symbol to the parameter dictionary"""
        sym_name = f"args[{len(self.param_dict)}]"
        self.param_dict[super()._print_Symbol(symbol)] = sym_name
        return sym_name

    def get_symbol(self, symbol: sympy.Symbol) -> str | None:
        """Returns string representing sympy symbol"""
        sym_name = super()._print_Symbol(symbol)
        if self.coord_dict.get(sym_name) is not None:
            return self.coord_dict[sym_name]
        elif self.dotcoord_dict.get(sym_name) is not None:
            return self.dotcoord_dict[sym_name]
        elif self.param_dict.get(sym_name) is not None:
            return self.param_dict[sym_name]
        else:
            return None


class GSLInflatoxPrinter(CInflatoxPrinter):
    """An extended version of the `CInflatoxPrinter` capable of converting some special functions to
    their GSL counterparts. For a list of supported functions, see `Compiler` class documentation."""

    HYPERH = "gsl_sf_hyperg"
    BESSELH = "gsl_sf_bessel"

    def __init__(
        self,
        coordinate_symbols: list[sympy.Symbol],
        coordinate_derivative_symbols: list[sympy.Symbol],
        settings=None,
    ):
        super().__init__(coordinate_symbols, coordinate_derivative_symbols, settings)
        self.required_headers = []

    def print_preamble(self, model_name: str):
        """Print necessary gsl include directives, as well as the err_setup() function, called by
        lib_inflx_rs when the library is loaded."""
        preamble = super().print_preamble(model_name)
        for required_header in self.required_headers:
            preamble += f"#include<gsl/{required_header}.h>"
        preamble += """// Declare external function for gsl error handling
#include<gsl/gsl_errno.h>
void err_setup(gsl_error_handler_t* rust_panic) {
    gsl_set_error_handler(rust_panic);
}
    """
        return preamble

    def update_preamble(self, header):
        """Add header to preamble"""
        if header not in self.required_headers:
            self.required_headers.append(header)

    def _print_hyper(self, expr):
        """printer for hypergeometric functions"""
        self.update_preamble(self.HYPERH)
        ap = expr.args[0]
        bq = expr.args[1]
        x = self.doprint(expr.args[2])

        type = (len(ap), len(bq))
        if type == (2, 0):
            return f"gsl_sf_hyperg_2F0({self.doprint(ap[0])}, {self.doprint(ap[1])}, {x})"
        elif type == (2, 1):
            return f"gsl_sf_hyperg_2F1({self.doprint(ap[0])}, {self.doprint(ap[1])}, {self.doprint(bq[0])}, {x})"
        elif type == (1, 1):
            return f"gsl_sf_hyperg_1F1({self.doprint(ap[0])}, {self.doprint(bq[0])}, {x})"
        elif type == (0, 1):
            return f"gsl_sf_hyperg_0F1({self.doprint(bq[0])}, {x})"
        else:
            raise Exception(
                "Cannot compute hypergeometric functions other than 2F0, 2F1, 1F1 and 0F1"
            )

    def generic_print_bessel(self, expr, namedict):
        """printer for Bessel family of functions"""
        self.update_preamble(self.BESSELH)
        nu = expr.args[0]
        x = self._print_Symbol(expr.args[1])
        if nu.is_integer:
            nu = int(float(self._print_Symbol(nu)))
            try:
                name = namedict[f"{nu}"]
                return f"gsl_sf_bessel_{name}({x})"
            except KeyError:
                return f"gsl_sf_bessel_{namedict['int']}({nu}, {x})"
        try:
            return f"gsl_sf_bessel_{namedict['float']}({self._print_Symbol(nu)}, {x})"
        except KeyError:
            raise KeyError("No non-integer impl found.")

    def _print_besselj(self, expr):
        return self.generic_print_bessel(expr, {"0": "J0", "1": "J1", "int": "Jn", "float": "Jnu"})

    def _print_bessely(self, expr):
        return self.generic_print_bessel(expr, {"0": "Y0", "1": "Y1", "int": "Yn", "float": "Ynu"})

    def _print_besseli(self, expr):
        return self.generic_print_bessel(expr, {"0": "I0", "1": "I1", "int": "In", "float": "Inu"})

    def _print_besselk(self, expr):
        return self.generic_print_bessel(expr, {"0": "K0", "1": "K1", "int": "Kn", "float": "Knu"})

    def _print_jn(self, expr):
        return self.generic_print_bessel(expr, {"0": "j0", "1": "j1", "2": "j2", "int": "jl"})

    def _print_yn(self, expr):
        return self.generic_print_bessel(expr, {"0": "y0", "1": "y1", "2": "y2", "int": "yl"})


class CompilationArtifact:
    """Class representing the output of the `Compiler`. It contains all information
    necessary to access the compiled artifact.

    ### Compiler symbols
    The `Compiler` class maps all sympy symbols found in the expressions for the
    potential and projected Hesse matrix to arguments of two numpy arrays:
      - `x` for the scalar fields themselves.
      - `args` for all other symbols (model parameters).
    All functions and classes that make use of this `CompilationArtifact` class will
    most likely require the user to supply `x` and `args` as numpy arrays. Therefore,
    one must know which sympy symbols were mapped to which position in the `x` and
    `args` arrays. The `CompilationArtifact` class provides two methods for this:
    `symbol_lookup` and `print_sym_table`. See their documentation for more details.
    """

    symbol_printer = C99CodePrinter()

    def __init__(
        self,
        symbol_dictionary: dict,
        shared_object_path: str,
        n_fields: int,
        n_parameters: int,
        auto_cleanup: bool = True,
    ):
        self.symbol_dictionary = symbol_dictionary
        self.shared_object_path = shared_object_path
        self.n_fields = n_fields
        self.n_parameters = n_parameters
        self.auto_cleanup = auto_cleanup

    def __del__(self):
        # Delete compilation artifact
        if self.auto_cleanup:
            os.remove(self.shared_object_path)

    def lookup_symbol(self, symbol: sympy.Symbol) -> str | None:
        """returns the compiled symbol (string) for the supplied sympy symbol,
        if the sympy symbol is known, `None` otherwise. See class docs for more
        info on compiled symbols.

        ### Args
        `symbol` (`sympy.Symbol`): sympy symbol to be converted.

        ### Returns
        `str|None`: name of the supplied symbol (either `args[n]` or `x[n]`), or
        `None` if the symbol is unknown.
        """
        sym_name = self.symbol_printer._print_Symbol(symbol)
        if not isinstance(sym_name, str):
            return None
        else:
            return self.symbol_dictionary[sym_name]

    def print_sym_lookup_table(self):
        """prints full mapping of all known sympy symbols and their corresponding
        compiled symbols. See class docs for more info on compiled symbols.
        """
        print("[Symbol Dictionary]")
        for old, new in self.symbol_dictionary.items():
            print(f"{old} -> {new}")


class Compiler:
    """This class wraps the native platform C compiler. It can be used to generate,
    compile and link C code from a `HesseMatrix` instance to produce a `CompilationArtifact`
    which can be used to calculate consistency conditions. This process involves
    creating a symbol dictionary that maps all symbols used in the `HesseMatrix` to
    C-friendly symbols.

    ## Special function support
    By passing `link_gsl=True` to the constructor of this class, the GSL will be linked by the final
    binary. This allows inflatox to map some special functons from `scipy` to their GSL counterparts.
    Currently supported functions are:
    - Bessel functions (besselj, besseli, besselk, bessely, jn and yn)
    - Hypergeometric functions (2F1, 2F0, 1F1 and 2F0)
    If you have the need for more special functions or are experiencing other issues with the gsl
    feature, contact the authors or open an issue on [github](https://github.com/smups/inflatox/issues)
    """

    c_prefix = "inflx_auto_"
    lib_prefix = "libinflx_auto_"

    default_zigcc_flags = [
        "-O3",
        "-Wall",
        "-Werror",
        "-fpic",
        "-lm",
        "-march=native",
        "-shared",
        "-std=c17",
    ]
    # The linker option -Wl --no-as-needed is required on Fedora/Redhat based systems. It could
    # very well be the case that this does not work on Debian/Ubuntu based systems.
    gsl_zigcc_flags = ["-lgsl", "-Wl,--no-as-needed", "-lgslcblas"]

    def __init__(
        self,
        model: InflationModel,
        output_path: str | None = None,
        cleanup: bool = True,
        silent: bool = False,
        link_gsl: bool = False,
        compiler_flags: list[str] | None = None,
    ):
        """Constructor for a C Compiler (provided by zig-cc), which can be used
        to convert the provided `HesseMatrix` object into a platform- and arch-specific
        shared library object.

        ### Examples
        To compile a previously calculated Hesse matrix, we simply construct a
        `Compiler` instance and call `.compile()` on it:
        ```python
        artifact = inflatox.Compiler(hesse_matrix).compile()
        ```
        See the docs for `HesseMatrix` and `SymbolicCalculation` for info on how to
        obtain a `HesseMatrix` instance.

        ### Args
        - `hesse_matrix` (HesseMatrix): HesseMatrix object that will be turned into
          C code and compiled.
        - `output_path` (str | None, optional): output path of compilation artifacts.
          Will auto-select the platform-defined temporary folder if option is set to
          `None`. Defaults to `None`.
        - `cleanup` (bool, optional): if `True`, generated artifacts will be deleted
          when they are no longer necessary. Defaults to True.
        - `silent` (bool, optional): if `True`, no console output will be
          generated. Defaults to `False`
        - `link_gsl` (bool, optional): enables experimental gsl (GNU Scientific Library) support for
          output binary. This enables some special functions to be compiled by inflatox. Enabling this
          binary requires the gls library to be installed and available to the linker. Defaults to False.
        - `compiler_flags` (list(str)|None, optional): replace default compiler flags with user-supplied
          ones. Make sure to link libmath and libgsl/libgslcblas (if link_gls==True). The default compiler
          flags can be found under `Compiler.default_zigcc_flags` and `Compiler.gsl_zigcc_flags`.
          Defaults to None.
        """
        self.output_file = (
            open(output_path, "w")
            if output_path is not None
            else tempfile.NamedTemporaryFile(
                mode="wt", delete=False, suffix=".c", prefix=Compiler.c_prefix
            )
        )
        self.symbolic_out = model
        self.cleanup = cleanup
        self.silent = silent
        self.gsl = link_gsl
        self.zigcc_opts = [flag for flag in self.default_zigcc_flags]
        # Add gsl linker flags
        if link_gsl:
            for flag in self.gsl_zigcc_flags:
                self.zigcc_opts.append(flag)
        # Override default flags if user supplied some
        if compiler_flags is not None:
            self.zigcc_opts = compiler_flags

    def _generate_c_file(self):
        """Generates C source file from Hesse matrix specified by the constructor"""
        # Initialise C-code printer
        fields = self.symbolic_out.coordinates
        dotfields = self.symbolic_out.coordinate_tangents
        ccode_writer = (
            GSLInflatoxPrinter(fields, dotfields)
            if self.gsl
            else CInflatoxPrinter(fields, dotfields)
        )

        contents = ""

        # Write potential
        potential_body = textwrap.fill(
            ccode_writer.doprint(self.symbolic_out.potential).replace(", ", ","),
            width=100,
            tabsize=4,
            break_long_words=False,
            break_on_hyphens=False,
        ).replace("\n", "\n    ")
        contents += f"""
double V(const double x[], const double args[]) {{
  return {potential_body};
}}
"""
        # Write all the components of the Hesse matrix
        for a in range(self.symbolic_out.dim):
            for b in range(self.symbolic_out.dim):
                function_body = ccode_writer.doprint(self.symbolic_out.hesse_cmp[a][b]).replace(
                    ")*", ") *\n    "
                )
                contents += f"""
double v{a}{b}(const double x[], const double args[]) {{
  return {function_body};
}}
"""
        # Write all the components of the first basis vector (gradient)
        for idx, cmp in enumerate(self.symbolic_out.basis[0]):
            function_body = ccode_writer.doprint(cmp).replace(")*", ") *\n    ")
            contents += f"""
double g{idx}(const double x[], const double args[]) {{
  return {function_body};
}}
"""
        # Write the size of the gradient
        gradnorm_body = ccode_writer.doprint(self.symbolic_out.gradient_square).replace(
            ")*", ") *\n    "
        )
        contents += f"""
double grad_norm_squared(const double x[], const double args[]) {{
  return {gradnorm_body};
}} 
"""
        # Write the equations of motion
        for a in range(self.symbolic_out.dim):
            function_body = ccode_writer.doprint(self.symbolic_out.eom_fields[a])
            contents += f"""
double eom{a}(const double x[], const double xdot[], const double args[]) {{
    return {function_body};
}}                
"""
        # Write the equations of motion for the hubble parameter
        contents += f"""
double eomh(const double x[], const double xdot[], const double args[]) {{
    return {ccode_writer.doprint(self.symbolic_out.eom_h)};    
}}

double eomhdot(const double x[], const double xdot[], const double args[]) {{
    return {ccode_writer.doprint(self.symbolic_out.eom_hdot)};
}}
"""

        # Output to actual file
        with self.output_file as out:
            # Write preamble
            out.write(ccode_writer.print_preamble(self.symbolic_out.model_name))

            # Write global constants
            v = __abi_version__.split(".")
            out.write(f"""
//Inflatox version used to generate this file
const uint16_t VERSION[3] = {{{v[0]},{v[1]},{v[2]}}};
//Number of fields (dimensionality of the scalar manifold)
const uint32_t DIM = {self.symbolic_out.dim};
//Number of parameters
const uint32_t N_PARAMTERS = {len(ccode_writer.param_dict)};
//Model name
char *const MODEL_NAME = \"{self.symbolic_out.model_name}\";
// Gsl flag
const char USE_GSL = {1 if self.gsl else 0};
""")
            # Write actual file contents
            out.write(contents)

        # Update symbol dictionary
        self.symbol_dict = ccode_writer.coord_dict
        self.symbol_dict.update(ccode_writer.param_dict)

    def _zigcc_compile_and_link(self):
        source_path = f"{self.output_file.name}"
        source_name = os.path.basename(source_path)[:-2].removeprefix(Compiler.c_prefix)
        lib_name = f"{Compiler.lib_prefix}{source_name}.bin"
        lib_path = f"{tempfile.tempdir}/{lib_name}"

        # Compile source with zig
        zigargs = [
            sys.executable,
            "-m",
            "ziglang",
            "cc",
            "-o",
            lib_path,  # out
            source_path,  # in
            *self.zigcc_opts,  # compiler options
        ]

        process = subprocess.Popen(zigargs, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out = b""

        while process.stdout.readable():
            line = process.stderr.readline()
            if not line:
                break
            out += line
            if not self.silent:
                print(line.decode("utf-8"), end=None)

        exitcode = process.wait()
        return (source_path, lib_path, (out, exitcode))

    def compile(self) -> CompilationArtifact:
        """Compiles the Hesse matrix specified in the constructor of this class into
        a shared library that can be used in further calculations. This process involves
        creating a symbol dictionary that maps all symbols used in the `HesseMatrix`
        to C-friendly symbols. The output of this function contains this dictionary,
        see the docs of `CompilationArtifact` for more info.

        ### Examples
        To compile a previously calculated Hesse matrix, we simply construct a
        `Compiler` instance and call `.compile()` on it:
        ```python
        artifact = inflatox.Compiler(hesse_matrix).compile()
        ```
        See the docs for `HesseMatrix` and `SymbolicCaluclation` for info on how to
        obtain a `HesseMatrix` instance.

        ### Returns
          `CompilationArtifact`: artifact that can be used in further calculations.
          It contains info about the model and inflatox version used to create the
          artifact.
        """
        # (0) Say hello
        if not self.silent:
            print("Compiling model...")

        # (1) generate the actual C-source
        self._generate_c_file()

        # (2) run compiler and linker
        source_path, dylib_path, (output, exitcode) = self._zigcc_compile_and_link()

        # (3) cleanup unused artifacts
        if self.cleanup:
            os.remove(source_path)

        # (4) print output
        if exitcode != 0:
            if self.silent:
                print(output.decode("utf-8"))

            print(f'Problematic source file located at: "{source_path}"')
            raise Exception("Zig compiler error (see previous output)")

        # (R) return compilation artifact
        return CompilationArtifact(
            self.symbol_dict,
            dylib_path,
            self.symbolic_out.dim,
            len(self.symbol_dict) - self.symbolic_out.dim,
            auto_cleanup=self.cleanup,
        )
